from Node import Node


class Bot:
    """
    The Gabata bot maximizes the number of marbles in the players deposit
    slot.
    """

    def __init__(self, depth, player):
        """
        A bot is instantiated with a depth, head (node), and player (which side
        the bot is playing for).

        Inputs:
            depth (int): strength of the bot (Should be set less than 8)
            player (int): 1 or 2
        """
        self.depth = depth
        self.head = None
        self.player = player
        self.curr_player = None

    def gen_head(self, board):
        """
        Function sets off the bot. Creates the root node and the bot continues
        to create children nodes of all possible moves given past states of the
        board.

        Inputs:
            board (Board): the state for which the bot is finding the best move
        """
        self.head = Node(board, 0)
        # self.player = board.get_player()
        self.curr_player = board.get_player()

        self.gen_tree(self.head, board)

    def gen_tree(self, node, board):
        """
        Recursive function to create a tree stucture of all possible future states
        of the board until the given depth or no more moves are valid

        Inputs:
            node (Node): past node for which future child nodes with game states will be made
            board (Board): past Board game for which future states will be made
        """

        if (
            node.depth >= self.depth or board.game_over()
        ):  # len(board.valid_moves(board.get_player())) == 0:
            # base case
            # checks if the node added is at the bots final depth or no more possible moves are available
            node.value = node.board.points(self.player)
            return
        else:
            moves = board.valid_moves(board.get_player())
            # stores all the valid moves for the current board state

            for move in moves:  # for all the valid movies
                tempboard = board.copy()
                # create a temporary board and make one of the valid moves
                tempboard.move(move)
                new_node = Node(tempboard, node.depth + 1)
                # create a child node for the new resulting board state
                new_node.move_made = move
                node.children.append(new_node)
                self.gen_tree(new_node, tempboard)  # recusive step

    def recommend_best(self):
        """
        Function analyzes the move tree generated by the bot and recommends the
        move that results in the highest final score. Uses a stack to store all
        the nodes and for the leaf nodes, finds the one with the highest final
        score (value) and returns the first move that led to that game state

        Output:
            (int): best move
        """
        score = []
        for child in self.head.children:
            stack = [child]
            move_score = []

            while stack:
                node = stack.pop()

                if node.children == []:
                    move_score.append(node.value)
                else:
                    stack.extend(node.children)
                    # extends stack to include more children nodes

            score.append((child.move_made, max(move_score)))
            # stores the max score and the valid move that led to that state

        max_tuple = max(score, key=lambda x: x[1])
        # uses lambda and max function to find the move that has the highest score
        return max_tuple[0]

    def recommend_worst(self):
        """
        Function analyzes the move tree generated by the bot and recommends the
        worst that results in the lowest final score. Uses a stack to store all
        the nodes and for the leaf nodes, finds the one with the lowest final
        score (value) and returns the first move that led to that game state

        Output:
            (int): worst move
        """
        score = []
        for child in self.head.children:
            stack = [child]
            move_score = []

            while stack:
                node = stack.pop()

                if node.children == []:
                    move_score.append(node.value)
                else:
                    stack.extend(node.children)
                    # extends stack to include more children nodes

            score.append((child.move_made, min(move_score)))
            # stores the minimum score and the valid move that led to that state

        min_tuple = min(score, key=lambda x: x[1])
        # uses lambda and max function to find the move that has the highest score
        return min_tuple[0]
